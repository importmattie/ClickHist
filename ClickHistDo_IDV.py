__author__ = 'niznik'

# ClickHistDo is very much specific to the implementation of ClickHist
# In this IDV implementation, input data and relevant axis data are used
# to create multiple files usable with IDV to explore the environments that
# generated a scatter point from a ClickHist

import calendar
import datetime
import os
import sys
from subprocess import call
import time

class ClickHistDo:
    def __init__(self,lons,lats,times,startDatetime,bundle,**kwargs):

        """
        Initializes the ClickHistDo.
        :param lons: input longitude array matching the original dimensions
        of the input x and y data along that axis
        :param lats: input latitude array matching the original dimensions
        of the input x and y data along that axis
        :param times: input time array matching the original dimensions
        of the input x and y data along that axis
        :param startDatetime: a datetime object containing the date and time
        needed to calculate the time of the event based on values within the
        times array. This is needed because netCDF files usually store time
        as some interval (seconds, minutes, hours, days) after a reference
        time. In the case of ClickHist, the user is expected to convert
        the times array to seconds for input.
        :param bundle: The name of the template bundle to be altered
        :param kwargs: many options - see wiki for now
        :return:
        """

        # Check if we are in Linux, OS X, or something unsupported
        self.os = sys.platform

        # Initialize the three relevant dimensions based on input from
        # ClickHist as well as the reference start time
        self.lons = lons
        self.lats = lats
        self.times = times
        self.lonLen = len(self.lons)
        self.latLen = len(self.lats)
        self.timeLen = len(self.times)
        self.startDatetime = startDatetime

        # Set default values for variable names, metadata, and
        # percentiles
        # (xVarName and yVarName can be changed by kwargs below,
        # the rest changed on an individual 'do')
        self.xVarName = 'xVar'
        self.yVarName = 'yVar'
        self.metadata = ''
        self.xPer = 99.9
        self.yPer = 99.9

        # Set default offsets for IDV bundle
        self.lonOffset = 5.0
        self.latOffset = 5.0
        self.dtFromCenter = (2*3600)*1000

        # Set name of bundle template to alter
        self.bundleInFilename = bundle

        # Set message to give after one click in ClickHist
        self.doObjectHint = 'save IDV bundle...'

        #Handle kwargs for output
        if('xVarName' in kwargs):
            self.xVarName = kwargs['xVarName']
        if('yVarName' in kwargs):
            self.yVarName = kwargs['yVarName']
        if('lonOffset' in kwargs):
            self.lonOffset = kwargs['lonOffset']
        if('latOffset' in kwargs):
            self.latOffset = kwargs['latOffset']
        if('dtFromCenter' in kwargs):
            self.dtFromCenter = kwargs['dtFromCenter']*1000

    def do(self,flatIndex,**kwargs):

        """

        :param flatIndex: Location of data in the flattened, 1D x and y data
        arrays. Combined with the lengths of each dimension (here, lon, lat,
        and time), this can be used to back out the dimensionalized data and
        thus the associated values for each dimension (i.e. the longitude,
        latitude, and time of the data point).
        :param kwargs: metadata - words to display in the output specific
        to the case, xPer,yPer - the percentiles of the x and y data, xyVals -
        a string containing the x and y data values to display to the user
        :return:
        """

        # Check if the metadata tag was included
        # Also check if the x and y percentiles were passed along
        if('metadata' in kwargs):
            self.metadata = kwargs['metadata']
        if('xPer' in kwargs):
            self.xPer = kwargs['xPer']
        if('yPer' in kwargs):
            self.yPer = kwargs['yPer']

        # Make sure output folders exist
        #
        # Tmp is where some files are processed before being moved to their
        # proper locations
        # GeneratedBundles is the folder for .xidv files written by this code
        # GeneratedBundlesZ is the folder for .zidv files generated when
        # the .isl script is run
        # ImageScripts stores the .isl scripts that generate image, movie, and
        # .zidv output
        # Images is where the image and movies generated by the .isl script
        # are stored
        #
        # Note that GeneratedBundlesZ and Images are not necessary at runtime
        # here, but they will be needed as soon as the user runs the .isl
        # script so it's best to make them ahead of time to avoid errors
        if(os.path.exists('./Output/Tmp/') == False):
            call('mkdir ./Output/Tmp/',shell=True)
        if(os.path.exists('./Output/GeneratedBundles/') == False):
            call('mkdir ./Output/GeneratedBundles/',shell=True)
        if(os.path.exists('./Output/GeneratedBundlesZ/') == False):
            call('mkdir ./Output/GeneratedBundlesZ/',shell=True)
        if(os.path.exists('./Output/ImageScripts/') == False):
            call('mkdir ./Output/ImageScripts/',shell=True)
        if(os.path.exists('./Output/Images/') == False):
            call('mkdir ./Output/Images/',shell=True)

        # Notify the user that the processing has begun
        print('Saving IDV bundle...')

        # Grab the current Unix/Epoch time as a placeholder tag for the
        # temporary results
        currentUnixTime = str(int(time.time()))
        basisBundleFile = './Output/Templates/'+self.bundleInFilename
        tempBundleFile = './Output/Tmp/tempBundle_'+currentUnixTime+'.xidv'

        # Determine the longitude, latitude, and time of the point passed
        # to Do
        inputLonIndex,inputLatIndex,inputTimeIndex = self.find3DIndices(flatIndex)
        inputLon = self.lons[inputLonIndex]
        inputLat = self.lats[inputLatIndex]
        inputDatetime = self.startDatetime+datetime.timedelta(0,(self.times[inputTimeIndex]))
        inputTime = int(calendar.timegm(inputDatetime.timetuple()))

        # Inform the user of the time and location of the point
        # And if passed, the values of X and Y as well
        print(inputDatetime)
        print("{:3.0f}".format(inputLon)+' E '+"{:2.0f}".format(inputLat)+' N')
        if('xyVals' in kwargs):
            print(kwargs['xyVals'])
        if(('xPer' in kwargs) and ('yPer' in kwargs)):
            print('x%: '+"{:2.3f}".format(kwargs['xPer'])+' '+
                  'y%: '+"{:2.3f}".format(kwargs['yPer']))

        # Based on the lon, lat, and time, determine all necessary input
        # to create an .xidv bundle
        # First, the edges of the display window
        westLon = str(inputLon-self.lonOffset)
        eastLon = str(inputLon+self.lonOffset)
        southLat = str(inputLat-self.latOffset)
        northLat = str(inputLat+self.latOffset)

        # Next, the start and end time for the time looping
        adjTime = int(inputTime)*1000
        startTime = str(adjTime-self.dtFromCenter)
        endTime = str(adjTime+self.dtFromCenter)
        # IDV wants these in minutes (hence dividing by 60*1000 to convert
        # out of milliseconds)
        startOffset = str(0)
        endOffset = str((self.dtFromCenter*2)/(60*1000))

        # Determine the filename based on various parameters and set the name
        # for the final .xidv file that is written
        timeTag = self.convertToYMDT(inputTime)
        commonFilename = self.xVarName+'_'+self.yVarName+'_'+\
                         "{:005.0f}".format(min(1000*self.xPer,99999))+'_'+\
                         "{:005.0f}".format(min(1000*self.yPer,99999))+'_'+\
                          str("%03i"%inputLon)+'_'+str("%02i"%inputLat)+'_'+timeTag
        finalBundleFile = './Output/GeneratedBundles/'+commonFilename+'.xidv'

        # Preset longitude dummy values in the .xidv template to be
        # replaced by the values calculated above
        centerLonFiller = '-154.123456789'
        lonLenFiller = '2.123456789'
        minLonFiller = '-155.1851851835'
        maxLonFiller = '-153.0617283945'
        incLonFiller = '0.345678912'

        # Same, but latitude
        centerLatFiller = '0.135792468'
        latLenFiller = '1.592592592'
        minLatFiller = '-0.660503828'
        maxLatFiller = '0.932088764'
        incLatFiller = '0.234567891'

        # Same, but time and metadata
        startTimeFiller = '1117594837000'
        endTimeFiller = '1117616461000'
        startOffsetFiller = '-119.87654321'
        endOffsetFiller = '361.23456789'
        metadataFiller = 'replaceme_METADATASTRING_replaceme'

        # The flag for dealing with backup in OS X and Linux is different
        # Set it here based on the OS that was determined upon initialization
        backupTag = ''
        if(self.os.startswith('darwin')):
            backupTag = '-i \'.bckp\''
        elif(self.os.startswith('linux')):
            backupTag = '-i.bckp'

        # Each call to sed here replaces one of the dummy lon/lat/time values
        # with the values appropriate to the passed data point
        call('sed \'s/'+minLonFiller+'/'+westLon+'/\' '+basisBundleFile+' > '+tempBundleFile,shell=True)
        call('sed '+backupTag+' \'s/'+maxLonFiller+'/'+eastLon+'/\' '+tempBundleFile,shell=True)
        call('sed '+backupTag+' \'s/'+minLatFiller+'/'+southLat+'/\' '+tempBundleFile,shell=True)
        call('sed '+backupTag+' \'s/'+maxLatFiller+'/'+northLat+'/\' '+tempBundleFile,shell=True)
        call('sed '+backupTag+' \'s/'+centerLonFiller+'/'+str(inputLon)+'/\' '+tempBundleFile,shell=True)
        call('sed '+backupTag+' \'s/'+centerLatFiller+'/'+str(inputLat)+'/\' '+tempBundleFile,shell=True)
        call('sed '+backupTag+' \'s/'+lonLenFiller+'/'+str(self.lonOffset*2)+'/\' '+tempBundleFile,shell=True)
        call('sed '+backupTag+' \'s/'+latLenFiller+'/'+str(self.latOffset*2)+'/\' '+tempBundleFile,shell=True)
        call('sed '+backupTag+' \'s/'+incLonFiller+'/'+str(self.lonOffset/2.)+'/\' '+tempBundleFile,shell=True)
        call('sed '+backupTag+' \'s/'+incLatFiller+'/'+str(self.latOffset/2.)+'/\' '+tempBundleFile,shell=True)
        call('sed '+backupTag+' \'s/'+startTimeFiller+'/'+startTime+'/\' '+tempBundleFile,shell=True)
        call('sed '+backupTag+' \'s/'+endTimeFiller+'/'+endTime+'/\' '+tempBundleFile,shell=True)
        call('sed '+backupTag+' \'s/'+startOffsetFiller+'/'+startOffset+'/\' '+tempBundleFile,shell=True)
        call('sed '+backupTag+' \'s/'+endOffsetFiller+'/'+endOffset+'/\' '+tempBundleFile,shell=True)
        call('sed '+backupTag+' \'s/'+metadataFiller+'/'+self.metadata+'/\' '+tempBundleFile,shell=True)

        # Save the bundle with a recognizable filename
        call('mv '+tempBundleFile+' '+finalBundleFile,shell=True)
        call('rm '+tempBundleFile+'.bckp',shell=True)

        # Inform the user of success
        print('Saved!')

        # Now create the ISL file - a bit less involved
        basisISL = './Output/Templates/idvMovieOutput_fillIn.isl'
        tempISL = './Output/ImageScripts/idvImZIDVOutput_'+commonFilename+'.isl'

        # Process a few replacements via sed
        call('sed \'s/BUNDLENAME/'+commonFilename+'/\' '+basisISL+' > '+tempISL,shell=True)
        call('sed '+backupTag+' \'s/MOVIENAME/'+commonFilename+'/\' '+tempISL,shell=True)
        call('sed '+backupTag+' \'s/IMAGENAME/'+commonFilename+'/\' '+tempISL,shell=True)
        call('sed '+backupTag+' \'s/\"METADATA\"/\"'+self.metadata+'\"/\' '+tempISL,shell=True)

        # Clean up backup files
        call('rm '+tempISL+'.bckp',shell=True)

        return

    def convertToYMDT(self,unixTime):
        """
        Converts a Unix/Epoch time given in seconds to a YMDT string for
        file outputs
        :param unixTime: A Unix/Epoch time, in units of seconds
        :return: a YMDT string (e.g. Jan 1, 2001 at 12:35 becomes
        20010101_1235)
        """
        ymdt = datetime.datetime.utcfromtimestamp(unixTime)
        return str(ymdt.year)+"{:02.0f}".format(ymdt.month)+"{:02.0f}".format(ymdt.day)+'_'+\
               "{:02.0f}".format(ymdt.hour)+"{:02.0f}".format(ymdt.minute)

    def find3DIndices(self,flatIndex):
        """
        Finds the index of the appropriate latitude, longitude, and time
        based on the 1D index for the flattened data. This is accomplished
        by the input data following the assumed order (when flattened, loop
        through all longitudes, then all longitudes for the next latitude, etc.
        until both all latitudes and longitudes have been seen for a time, then
        next time, etc.)
        :param flatIndex: The 1D index of the x and y data in the flattened
        arrays
        :return: (1) the index of the longitude, (2) the index of the latitude,
        (3) the index of the time
        """
        lon = flatIndex%self.lonLen
        lat = (flatIndex/self.lonLen)%self.latLen
        time = flatIndex/(self.lonLen*self.latLen)
        return lon,lat,time